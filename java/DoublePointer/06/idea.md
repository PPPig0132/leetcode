# BG (V1.x:自己写的 2.x 看别人的)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

# V1.0

先将数组进行排序（防止返回重复的三元组）

对数组中0的一半元素进行操作

固定一个元素找其他两个元素，~确定数组中0的位置~

第一个元素a（小于0的）

第二个元素b（从第一个元素的后一个元素开始遍历，如果两数之和小于0，则找第三个数c，否则结束本循环）

a,b,c可以相同，但是a和a+1不能相同，三数之和为0，只要有一个数不一样，其他两个数就不一样

a不变的话b就需要去重，c不需要去重，因为c找到一个满足的就break了

result: **55**ms  **43.84**MB

```

```

# V2.0

三重循环可以优化为二重循环,

原思路：

a->b->c各用一层循环来查找

优化后：

确定a以后使用双指针算法来同时找b和c `(b+c=-a)` ，当对数组进行排序后，c一定比b大，因此前指针从前往后遍历b，后指针从后往前确定c，双指针的时间复杂度为O(N)，因此共计O($N^2$)

即将三层循环拆解为一重循环+双指针

```

```

知识点回顾：

当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从O($N^2$)减少至O(N)。
